%%%%%%%%%%%%%% MÉTODO eLECTROMAGNETICO/ SLN USANDO LA RUTINA DE %%%%%%%%%%%
%%%%%%%%%%%%%%    NEWTON RAPHSON PARA SISTEMAS NO LINEALES    %%%%%%%%%%%%%

%% Similar al caso del método de rayos, solo basta con definir las funciones 
% de tal manera que se pueda visualizar los cortes con las funciones
% respectivas.
num_of_points = 1000000;
n_co = 1.5;
n_cl = 1;
n_s = n_cl;
h = 1e-6;
lambda = 1e-6;
k_0 = 2*pi/lambda;

V = (k_0*h/2)*sqrt((n_co^2-n_cl^2));

if (V < pi/2)
    num_of_asints_tan = 0;
else
    num_of_asints_tan = 1 + floor((V - pi/2)/pi);
end

if (V < pi)
    num_of_asints_cot = 0;
else
    num_of_asints_cot = 1 + floor((V - pi)/pi);
end

fTE_pares = @(x) x.*tan(x);
fTE_impares = @(x) -x.*cot(x);

fTM_pares = @(x) (n_cl/n_co)^2*x.*tan(x);
fTM_impares = @(x) -(n_cl/n_co)^2*x.*cot(x);

circ_TETM = @(x) sqrt(V^2-x.^2);


xrtan = zeros(num_of_asints_tan + 1,num_of_points/(num_of_asints_tan + 1));
xrcot = zeros(num_of_asints_cot + 1,num_of_points/(num_of_asints_cot + 1));

xrcir = linspace(0,V,num_of_points);


if (V < pi/2) && (V < pi)
    xrtan = linspace(0,V,num_of_points);
    xrcot = linspace(0,V,num_of_points);
elseif  (V < pi) 
    xrcot = linspace(0,V,num_of_points);
    for i = 1:num_of_asints_tan + 1
        if (i == 1)
            xrtan(i,:) = linspace(0,pi/2,num_of_points/(num_of_asints_tan + 1));
        else
            xrtan(i,:) = linspace(0.001 + xrtan(i-1,num_of_points/(num_of_asints_tan + 1)) ...
                                , 3*pi/2 + (i-2)*pi, num_of_points/(num_of_asints_tan + 1));
        end
    end
else
    for i = 1:num_of_asints_tan + 1
        if (i == 1)
            xrtan(i,:) = linspace(0,pi/2,num_of_points/(num_of_asints_tan + 1));
        else
            xrtan(i,:) = linspace(0.001 + xrtan(i-1,num_of_points/(num_of_asints_tan + 1)) ...
                                , 3*pi/2 + (i-2)*pi, num_of_points/(num_of_asints_tan + 1));
        end
    end

    for i = 1:num_of_asints_cot + 1
        
        if (i == 1)
            xrcot(i,:) = linspace(0 , pi, num_of_points/(num_of_asints_cot + 1));
        else
            xrcot(i,:) = linspace(0.001 + xrcot(i-1,num_of_points/(num_of_asints_cot + 1)) ...
                                , 2*pi + (i-2)*pi, num_of_points/(num_of_asints_cot + 1));
        end
    end
end




figure;
sgtitle('Método Electromagnético');

FTE_pares = zeros(num_of_asints_tan + 1, num_of_points/(num_of_asints_tan + 1));
FTE_impares = zeros(num_of_asints_cot + 1, num_of_points/(num_of_asints_cot + 1));

subplot(1,2,1);
hold on;

for i = 1:num_of_asints_tan + 1
    FTE_pares(i,:) = fTE_pares(xrtan(i,:));
    plot(xrtan(i,:),FTE_pares(i,:));
end

for i = 1:num_of_asints_cot + 1
    FTE_impares(i,:) = fTE_impares(xrcot(i,:));
    plot(xrcot(i,:),FTE_impares(i,:));
end

Cir = circ_TETM(xrcir);


plot(xrcir,Cir);

xlabel('$\kappa \frac{h}{2}$','FontWeight', 'bold', 'FontSize', 16, 'FontName', 'Arial', 'Interpreter', 'latex');
ylabel('$\gamma \frac{h}{2}$','FontWeight', 'bold', 'FontSize', 16, 'FontName', 'Arial', 'Interpreter', 'latex');
xlim([0,V+1]);
ylim([0,V+1]);
title('Modos TE')

hold off;

FTM_pares = zeros(num_of_asints_tan + 1, num_of_points/(num_of_asints_tan + 1));
FTM_impares = zeros(num_of_asints_cot + 1, num_of_points/(num_of_asints_cot + 1));

subplot(1,2,2);
hold on;

for i = 1:num_of_asints_tan + 1
    FTM_pares(i,:) = fTM_pares(xrtan(i,:));
    plot(xrtan(i,:),FTM_pares(i,:));
end

for i = 1:num_of_asints_cot + 1
    FTM_impares(i,:) = fTM_impares(xrcot(i,:));
    plot(xrcot(i,:),FTM_impares(i,:));
end

Cir = circ_TETM(xrcir);


plot(xrcir,Cir);

xlabel('$\kappa \frac{h}{2}$','FontWeight', 'bold', 'FontSize', 16, 'FontName', 'Arial', 'Interpreter', 'latex');
ylabel('$\gamma \frac{h}{2}$','FontWeight', 'bold', 'FontSize', 16, 'FontName', 'Arial', 'Interpreter', 'latex');
xlim([0,V+1]);
ylim([0,V+1]);
title('Modos TM')

hold off;


%% Hallados los modos para cada tipo de polarizacion TE y TM  ahora falta caracterizarlos, entonces
% las intersecciones de cada grafica con la circunferencia.


%% Para modos TE 

% Definimos la funcion vectorial la cual representara nuestro sitema de
% ecuaciones no lineal.

UTE_par = @(x,y) [y - x.*tan(x), x.^2 + y.^2 - V^2];
UTE_impar = @(x,y) [y + x.*cot(x), x.^2 + y.^2 - V^2];

JUTE_par = @(x,y) [-tan(x)-x.*(sec(x)).^2 ,1 ;2*x , 2*y];
JUTE_impar = @(x,y) [cot(x)-x.*(csc(x)).^2 ,1 ;2*x , 2*y];

[P0_TE, iter0_TE, err0_TE , Y0_TE] = newdim (UTE_par, JUTE_par, [1,3]  , 1e-3, 1e-4, 1000);
[P1_TE, iter1_TE, err1_TE , Y1_TE] = newdim (UTE_impar, JUTE_impar, [2.5,2.5]  , 1e-3, 1e-4, 1000);
[P2_TE, iter2_TE, err2_TE , Y2_TE] = newdim (UTE_par, JUTE_par, [3,1]  , 1e-3, 1e-4, 1000);


%% Para modos TM

% Definimos la funcion vectorial la cual representara nuestro sitema de
% ecuaciones no lineal.

UTM_par   = @(x,y) [y - (n_cl/n_co)^2*x.*tan(x) , x.^2 + y.^2 - V^2];
UTM_impar = @(x,y) [y + (n_cl/n_co)^2*x.*cot(x) , x.^2 + y.^2 - V^2];

JUTM_par = @(x,y) [(-tan(x)-x.*(sec(x)).^2)*(n_cl/n_co)^2 ,1 ;2*x , 2*y];
JUTM_impar = @(x,y) [(cot(x)-x.*(csc(x)).^2)*(n_cl/n_co)^2 ,1 ;2*x , 2*y];

[P0_TM, iter0_TM, err0_TM , Y0_TM] = newdim (UTM_par, JUTM_par, [1.23,3.28]  , 1e-3, 1e-4, 1000);
[P1_TM, iter1_TM, err1_TM , Y1_TM] = newdim (UTM_impar, JUTM_impar, [2.5,2.5]  , 1e-3, 1e-4, 1000);
[P2_TM, iter2_TM, err2_TM , Y2_TM] = newdim (UTM_par, JUTM_par, [3,1]  , 1e-3, 1e-4, 1000);

%% Ya se encontraron los angulos de incidencia de cada modo y la cantidad de
% modos , solo falta hallar el beta de cada uno y el indice efectivo, por
% lo que se hara una tabla en la cual se mostraran los datos.


% matrx_resutls_TE = zeros(4,3);
% 
% for i = 1:4
%     switch i
%         case 1
% 
%             matrx_resutls_TE(i,:) = 1:size(matrx_resutls_TE(i,:)) -1;
% 
%         case 2
% 
%             matrx_resutls_TE(i,:) = ;
% 
%         case 3
% 
% 
%         case 4
% 
% 
%         otherwise
%     end
%     matrx_resutls_TE(i,:) = ;
% end

%% Para modos TE

modo_TE = 0:2;

Beta_TE = zeros(1,length(modo_TE));

b1 = sqrt((k_0*n_co)^2-(P0_TE(1)*2/h)^2);
b2 = sqrt((P0_TE(2)*2/h)^2+(k_0*n_cl)^2);
b = (b1+b2)/2;

Beta_TE(1) =  b;


b1 = sqrt((k_0*n_co)^2-(P1_TE(1)*2/h)^2);
b2 = sqrt((P1_TE(2)*2/h)^2+(k_0*n_cl)^2);
b = (b1+b2)/2;

Beta_TE(2) =  b;

b1 = sqrt((k_0*n_co)^2-(P2_TE(1)*2/h)^2);
b2 = sqrt((P2_TE(2)*2/h)^2+(k_0*n_cl)^2);
b = (b1+b2)/2;

Beta_TE(3) =  b;

n_Efectivo_TE = [Beta_TE(1)/k_0, Beta_TE(2)/k_0, Beta_TE(3)/k_0];
Angulo_TE = [asind(n_Efectivo_TE(1)/n_co), ...
             asind(n_Efectivo_TE(2)/n_co), ...
             asind(n_Efectivo_TE(3)/n_co)];

% Create the table for TE modes
TTE = table(modo_TE', Beta_TE', n_Efectivo_TE', Angulo_TE', ...
'VariableNames', {'Modo', 'Beta [m^-1]', 'Índice efectivo','Ángulo de incidencia[°]'});
disp("/////////////////// Descripción modos TE ////////////////////////")
disp(TTE);


%% Para modos TM

modo_TM = 0:2;

Beta_TM = zeros(1,length(modo_TM));

b1 = sqrt((k_0*n_co)^2-(P0_TM(1)*2/h)^2);
b2 = sqrt((P0_TM(2)*2/h)^2+(k_0*n_cl)^2);
b = (b1+b2)/2;

Beta_TM(1) =  b;


b1 = sqrt((k_0*n_co)^2-(P1_TM(1)*2/h)^2);
b2 = sqrt((P1_TM(2)*2/h)^2+(k_0*n_cl)^2);
b = (b1+b2)/2;

Beta_TM(2) =  b;

b1 = sqrt((k_0*n_co)^2-(P2_TM(1)*2/h)^2);
b2 = sqrt((P2_TM(2)*2/h)^2+(k_0*n_cl)^2);
b = (b1+b2)/2;

Beta_TM(3) =  b;

n_Efectivo_TM = [Beta_TM(1)/k_0, Beta_TM(2)/k_0, Beta_TM(3)/k_0];

Angulo_TM = [asind(n_Efectivo_TM(1)/n_co), ...
             asind(n_Efectivo_TM(2)/n_co), ...
             asind(n_Efectivo_TM(3)/n_co)];

% Create the table for TM modes
TTM = table(modo_TM', Beta_TM', n_Efectivo_TM', Angulo_TM', 'VariableNames', ...
    {'Modo', 'Beta [m^-1]', 'Índice efectivo','Ángulo de incidencia[°]'});
disp("/////////////////// Descripción modos TM ////////////////////////")
disp(TTM);




